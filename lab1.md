---
title: 'Лабораторная работа 1'
author: 'А.В. Родионов'
fontsize: '14pt'
geometry: 'margin=2cm'
paper: 'a4'
lang: 'russian'
template: 'default.html'
---

# Начало работы с системой управления версиями Git

Основная задача, которую выполняют системы управления версиями -- сохранение
изменений в файле или группе файлов в определенные моменты времени. При
необходимости система управления версиями позволяет восстановить произвольную
сохраненную версию одного или более файлов. Кроме того, система управления
версиями позволяет анализировать разницу между различными состояниями группы
файлов во времени, определять, кто является автором того или иного изменения и
когда оно произошло. Хранение данных производится в специальном формате,
который учитывает только изменившиеся части файлов, поэтому накладные расходы
системы управления версиями сведены к минимуму. Среди подобных систем можно
выделить:

* локальные, которые управляют версиями исключительно на локальной файловой
  системе пользователя;
* централизованные, которые позволяют работать с группой файлов (проектом)
  множеству пользователей по сети, но хранят все изменения в одной базе данных,
  на центральном сервере;
* распределенные, в которых пользователи могут иметь какое угодно количество
  копий базы данных изменений, в сети и на локальном диске, при необходимости
  производя слияние изменений между этими базами.

Система управления версиями Git была выпущена в 2005 году для поддержки
процесса разработки ядра ОС Linux. С того времени она прошла большой путь
развития и широко применяется при разработке программного обеспечения.
Отличительной чертой Git является гибкая и эффективная система ветвления,
позволяющая реализовывать сложные нелинейные сценарии разработки и поддержки
ПО.

## Ключевые понятия Git

Идеология Git основывается на следующих отличительных особенностях:

1. В базе изменений (репозитории) хранятся изменения в образах проекта, а не его
   индивидуальных файлов. Это означает, что Git поддерживает состояние проекта
   на диске как специализированная файловая система.  При этом в репозитории
   сохраняются атрибуты файлов, время доступа и модификации, история удалений и
   переименований. Если при очередном сохранении образа какие-то файлы не
   изменились, для них сохраняется только ссылка на предыдущую версию.
2. Практически все операции над изменениями производятся локально. Все действия
   над проектом прежде всего оперируют локальной базой изменений на диске. Это
   позволяет полноценно работать с Git даже при отсутствии соединения с сетью.
3. Контроль целостности. Все изменения образа проекта подвергаются хэшированию
   по алгоритму SHA-1 и получившаяся шестнадцатеричная строка является
   уникальным идентификатором каждого набора изменений. При необходимости любое
   состояние проекта можно восстановить из репозитория, если известны первые
   несколько знаков его хэша. Наоборот, ни одно изменение в проекте невозможно
   без изменения текущего значения хэша, поэтому Git позволяет легко обнаружить
   поврежденные или утерянные при копировании файлы.
4. Большинство операций в Git -- недеструктивны. Любые действия над проектом
   можно отменить, поэтому, кроме специальных случаев, любые операции над
   версиями полностью безопасны.
5. Три состояния файлов. Файлы проекта Git могут находиться
   в одном из следующих состояний:

   * Сохраненное (committed): все изменения файла сохранены в локальный репозиторий Git и могут
   быть восстановлены в любой момент. База сохраненных изменений хранится в
   специальной директории внутри проекта, которая и называется "репозиторий".
   * Измененное (modified): файл был изменен, но его изменения пока не были
   подготовлены для записи в репозиторий.
   * Индексированное (staged): изменения в файле или группе файлов были
   записаны в буферную зону, которая хранится в репозитории в
   особых индексных файлах.

   Цикл разработки состоит из редактирования файлов, после чего те или иные
   файлы со своими изменениями добавляются в индекс. Изменения накапливаются в
   индексе и образуют набор, который связан неким общим смыслом и решаемыми
   задачами. Когда разработчик считает, что набор индексированных изменений
   завершен, индекс сохраняется в репозиторий. При этом для него вычисляется
   хэш, присваивается метка времени, сохраняется автор изменений и сообщение в
   журнал. Сохраненный набор изменений называется в терминологии Git
   "коммитом".

## Установка и начальные настройки

Для установки Git необходимо скачать дистрибутив для нужной операционной
системы с [официального сайта проекта](https://git-scm.com/download).
Существуют также пакеты управления версиями, включающие в себя настроенный Git,
и ориентированные на работу с популярными сетевыми репозиториями проектов,
такие как [Github Desktop](https://desktop.github.com). Помимо собственно
управления версиями они предоставляют удобные локальные средства для управления
удаленными копиями проектов.

Конфигурация Git задается как глобально, так и для индивидуальных пользователей
операционной системы. В последнем случае она располагается в домашней папке
пользователя, в файле `.gitconfig`. Для изменения конфигурации можно
редактировать его непосредственно или использовать команды из консоли. При
первой установке Git необходимо для данного пользователя сохранить
идентификационные данные, которыми в дальнейшем будут помечаться изменения
этого автора. Для этого в консоли следует выполнить команды:

    git config --global user.name "Имя Автора"
    git config --global user.email адрес@электронной.почты

Флаг `--global` означает, что конфигурация будет сохранена в основном
конфигурационном файле пользователя. При необходимости можно задавать параметры
без этого флага, тогда параметры конфигурации будут изменяться только для
текущего репозитория.

При создании коммита, Git запускает текстовый редактор для ввода сообщений в
журнал. Как правило, используется редактор для данной операционной системы по
умолчанию. При необходимости можно задать его в конфигурации следующей командой
(пример для 32-битной системы Windows и редактора Notepad++):

    git config --global core.editor "'C:/Program Files/Notepad++/notepad++.exe' -multiInst -nosession"
Для других версий ОС и редакторов потребуется изменить путь к исполняемому
модулю редактора и его флаги командной строки.

Команда `git config --list` позволяет вывести на консоль текущую конфигурацию
Git для данного пользователя и проекта.

## Работа в командной строке Git

Несмотря на то, что для Git существует множество оболочек и интеграций со
средами разработки, вся полнота функционала раскрывается в командной строке.
Для получения списка доступных команд и их краткого описания достаточно ввести
в консоли `git help`, а для получения детальной информации по конкретной
команде `git help <команда>`.

### Инициализация репозитория

Пустой репозиторий создается в папке проекта командой `git init`. Для того
чтобы Git начал отслеживать изменения в файлах, необходимо их добавить в
репозиторий и создать первый коммит. Например, если нужно отслеживать изменения
в файлах на языке Python, необходимо ввести следующие команды:

    git add *.py  
    git commit -m "Первый коммит"

Первая команда добавляет в индекс новые файлы, в данном случае все файлы с
расширением ".py" в текущей директории. Вторая команда создает коммит и
связывает с ним сообщение "Первый коммит".

### Клонирование репозитория

Репозитории Git могут быть произвольно скопированы и разработка в них может
вестись независимо и параллельно. Для локальных файлов достаточно просто
скопировать весь проект с директорией `.git`, которая содержит репозиторий. Для
удаленных репозиториев можно воспользоваться командой `git clone`, которая
эффективно передает по сети базу изменений и восстанавливает после копирования
состояние рабочей директории. Например, для того, чтобы создать локальную копию
репозитория, в котором хранится данное пособие, необходимо выполнить команду:

    git clone https://github.com/andviro/pamyatka.git

Помимо удаленных репозиториев, команда `git clone` может работать и с
локальными папками на диске.

### Проверка состояния файлов

Команда `git status` выводит на консоль информацию о проекте, а именно список
модифицированных файлов, список файлов, изменения в которых были
проиндексированы, а так же список файлов, не отслеживаемых репозиторием. Также
выводится название ветки, на которой находится текущий репозиторий и насколько
коммитов эта ветка отстает или опережает соответствующую ветку удаленного
репозитория.

### Добавление файлов

Команда `git add <имя или шаблон>` добавляет в индекс заданные файлы,
независимо, отслеживались они ранее репозиторием или нет. Если добавить
директорию, в том числе и текущую, в индекс будет добавлено все ее содержимое,
кроме игнорируемых файлов. Если не добавить флаг `--all`, команда `git add`
отказывается добавлять в индекс операции удаления, следую по умолчанию политике
недеструктивных действий. Если требуется удалить из проекта файл и
проиндексировать эту операцию для последующего включения в коммит, необходимо
выполнить команду `git rm <имя или шаблон>`.

## Игнорирование файлов

В ходе работы с проектом в его директориях могут появиться временные файлы или
иные результаты работы, которые нежелательно отслеживать в репозитории. Как
правило в проектах игнорируются объектные модули, полученные при компиляции,
исполняемые модули, резервные копии файлов. Список шаблонов файлов и
директорий, которые следует игнорировать, можно задать в файле `.gitignore`.
Пример файла, в котором задается игнорирование скомпилированных скриптов на
Python и содержимого директории `temp` приведен ниже:

    *.py[cow]
    temp/
    !temp/data.txt

Каждая строка файла соответствует одному шаблону игнорирования. Если строка
начинается с восклицательного знака, действие шаблона инвертируется и совпавшие
файлы и директории перестают игнорироваться. Например в примере выше
игнорируется содержимое директории `temp`, но файл `temp/data.txt` из этого
списка исключается. Строки в файле `.gitignore`, находящиеся ближе к концу,
имеют более высокий приоритет чем те, которые находятся в его начале. Для того,
чтобы шаблоны игнорирования начали действовать, необходимо, чтобы файл
`.gitignore` отслеживался репозиторием. Отдельные директории проекта могут
содержать свои `.gitignore`, шаблоны из которых добавляются основному файлу, с
большим приоритетом.

### Просмотр изменений

Если команда `git status` показывает наличие изменений, просмотреть их можно
командой `git diff`. При этом будут отображены изменения, которые были сделаны
в проекте, но еще не были добавлены в индекс. Команда `git diff --staged`
показывает только проиндексированные изменения, что может быть полезным перед
тем, как выполнить коммит. 

### Сохранение изменений

Команда `git commit` переводит изменения из индекса в репозиторий. Перед этим,
Git запускает сконфигурированный текстовый редактор, в котором предлагает
ввести короткое сообщение, идентифицирующее будущий коммит. Если сообщения не
было введено, коммит отменяется. 

Если известно, что все текущие изменения в отслеживаемых файлах войдут в
коммит, не обязательно разделять процесс на два этапа. Команда `git commit -a`
автоматически добавляет в индекс все измененные файлы и предлагает ввести
сообщение в журнал. Команду следуюет использовать с осторожностью, так как в
коммит могут нечаянно попасть изменения, которые планировалось сохранить в
следующем коммите.

### Удаление и переименование файлов

Команда `git rm`, которая уже упоминалась выше, удаляет файл из рабочей копии
проекта и из добавляет удаление в индекс. При следующем коммите удаленный файл
перестает отслеживаться репозиторием. Файлы с изменениями, внесенными в индекс,
можно удалить только командой `git rm -f <шаблон>`. Если необходимо перестать
отслеживать файл, при этом оставив его на диске, используется команда `git rm
--cached <шаблон>`.

Переименование и перенос файлов в новые директории осуществляется командой `git
mv <что переименовывать> <во что переименовывать>`. При этом, так же как и для
команды `git rm`, результат операции будет автоматически добавлен в индекс. 

### Просмотр истории изменений

Команда `git log` позволяет просмотреть журнал коммитов с сообщениями, хэшами и
датами изменений. Это может быть полезно для последующего ветвления от нужного
коммита или отката изменений. Просмотреть вместе с сообщениями журнала и сами
изменения можно добавив флаг `-p`. При этом вывод может быть достаточно
длинным, поэтому отсечь все коммиты кроме первых N можно добавив флаг `-N`.
Например, если интересуют изменения только в трех последних коммитах,
необходимо ввести команду:

    git log -p -3

Флаг `--stat` добавляет к сообщениям коммитов краткую сводку изменений в
файлах, а флаг `--graph` рисует в псевдографике дерево ветвлений. 

### Отмена изменений

Если в только что сделанный коммит необходимо добавить новые изменения из
индекса, используется команда `git commit --amend`. При этом последний коммит
из репозитория отменяется, его изменения объединяются с текущим индексом и
формируется новый коммит с тем же сообщением журнала и со всеми сделанными
изменениями. При отсутствии изменений в индексе, `git commit --amend` позволяет
просто изменить сообщение в журнале.

Убрать изменения из индекса можно командой `git reset HEAD <шаблон файлов>`.
Совпавшие с шаблоном файлы будут отмечены как измененные, но не
проиндексированные.

Для того, чтобы отменить изменения в файлах, используется команда `git checkout
-- <шаблон имен файлов>`. Пользоваться этой командой следует с осторожностью,
так как отмененные изменения восстановить уже будет невозможно.

Команда `git reset --hard` позволяет сбросить и индекс и рабочую копию проекта
в состояние последнего сохраненного коммита. При этом также может быть утеряна
информация о несохраненных изменениях.
 
### Тэги

С помощью тэгов можно отметить определенные стадии развития проекта. Тэг
представляет собой метку коммита и бывает аннотированным и легким.
Аннотированный тэг имеет имя, хэш, дату и автора, сохраняется как полноценный
объект в репозитории. Легкий тэг представляет собой именованный указатель на
заданный коммит. Пример создания аннотированного тэга для текущего состояния
репозитория с меткой "1.0.1" и сообщением в журнале:

    git tag -a 1.0.1 -m "Version 1.0.1"

Легковесный тэг с такой же меткой можно было бы создать командой:

    git tag 1.0.1

Тэги передаются на удаленный репозиторий по метке, например для предыдущего
примера отправить тэг на репозиторий `origin` можно было бы командой:

    git push origin 1.0.1

Если необходимо отправить все тэги, можно использовать команду 

    git push --tags

Тэги можно использовать в дальнейшем для ответвления от ключевых точек в
истории развития проекта.

## Задание для самостоятельной работы

* Установите на компьютер Git и произведите его начальную настройку
* Создайте произвольный проект, состоящий из нескольких файлов и поддиректорий.
* Инициализируйте в нем репозиторий Git и добавьте туда содержимое проекта.
* Создайте и добавьте файл `.gitignore` и проверьте его действие.
* Произведите несколько операций над файлами проекта, в том числе удаление и перемещение.
* Просмотрите разницу между исходными файлами и текущими изменениями
* Отмените индексацию изменений в одном из файлов
* Сохраните изменения в коммитах так, чтобы несколько коммитов охватывали
  разные группы файлов.
* Удалите один из файлов из индекса, не удаляя его с диска. Добавьте его в
  `.gitignore`.
* Добавьте изменения в последний коммит и измените его сообщение в журнале.
* Создайте локальный клон репозитория проекта.
* Привяжите клон к исходному репозиторию под именем `clone`
* Обменяйтесь изменениями между клоном и исходным репозиторием
* Отметьте тэгами точки в истории проекта
* Обменяйтесь тэгами между исходным репозиторием и его клоном
* Просмотрите информацию об обоих репозиториях

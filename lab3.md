---
title: 'Лабораторная работа 3'
author: 'А.В. Родионов'
fontsize: '14pt'
geometry: 'margin=2cm'
paper: 'a4'
lang: 'russian'
template: 'default.html'
---

# Работа с удаленными репозиториями Git

Модель разработки с помощью Git предполагает, что пользователи работают с множеством копий
репозитория. Благодаря этому, разработчики в большой команде могут решать свои задачи независимо
друг от друга, имея полный контроль над своими копиями проекта. Для синхронизации изменений между
разными копиями, Git предоставляет механизм удаленных (remote) репозиториев, связь с которыми может
осуществляться по протоколу HTTP(HTTPS), SSH, или просто через локальную файловую систему.
Распространена модель работы, в которой существует общий удаленный репозиторий,
доступный по сети, в который участники периодически отправляют свои изменения. Для этого они
устанавливают связь между своими локальными копиями и "главной" сетевой копией. В базе Git удаленный
репозиторий представляет собой сохраненный URL внешней копии и набор ссылок на ветки, тэги и другие
объекты. При необходимости, внешних репозиториев можно подключить сколько угодно.

## Создание внешнего репозитория

В сети существует множество бесплатных сервисов, которые предлагают услуги по хранению репозиториев
и синхронизации с ними. К ним относятся [Github](https://github.com),
[Bitbucket](https://bitbucket.org), [Gitlab](https://gitlab.com) и др. После регистрации они
предоставляют Web-интерфейс, который позволяет создавать новые репозитории и управлять ими. Сходной
функциональности можно добиться также средствами локальной файловой системы, например, для хранения
копии репозитория не во внешнем сервисе, а на резервном носителе. Функционально такой репозиторий
ничем не отличается от внешнего сетевого. Для его создания на диске используется команда `git init
<имя репозитория>.git --bare`. Традиционно, имя внешнего репозитория заканчивают суффиксом ".git".
Созданная таким образом директория представляет собой пустую базу Git, не имеющую рабочего дерева
проекта. Такой репозиторий не предназначен для редактирования файлов, а только хранит базу коммитов.

## Привязка репозитория и отслеживание

Добавление удаленных репозиториев осуществляется командой `git remote add <имя> <URL>`. Имя не
должно содержать пробелов, а URL может представлять собой либо ссылку на внешний ресурс, либо имя
локальной директории, созданной командой `git init --bare`. Просмотреть список удаленных
репозиториев, связанных с текущим, можно командой `git remote`. С ключом `-v`, команда выводит
вместе с именами репозиториев их URL. Ветки из удаленного репозитория имеют имена вида `<имя
репозитория>/<имя ветки>`, что отличает их от локальных. Для того, чтобы установить соответствие
между локальной веткой и удаленной, локальная переводится в режим отслеживания. В этом режиме Git
позволяет выяснить, насколько локальная ветка отличается от ее удаленной версии и притягивать (pull)
внешние изменения или выталкивать (push) локальные в удаленный репозиторий.

## Обмен изменениями

Для того, чтобы скопировать базу коммитов в пустой внешний репозиторий
необходимо выполнить команду `git push -u <имя удаленного репозитория> --all`. Ключ `-u` означает,
что отправляемые ветки будут переведены в режим отслеживания, а ключ `--all` -- что нужно проделать
эту операцию со всеми ветками текущего локального репозитория. Также можно перенести во внешний
репозиторий имеющиеся тэги, командой `git push -u <имя удаленного репозитория> --tags`.

Часто имеет место обратная ситуация: уже существует удаленный репозиторий с изменениями и нужно
создать локальную копию, которая будет отслеживать его ветки. Для создания такой локальной копии
используется команда `git clone <URL репозитория>`. При клонировании, в локальном репозитории
автоматически добавляется удаленный репозиторий `origin`, а локальная ветка `master` начинает
отслеживать удаленную ветку `origin/master`.

Перевести другие локальные ветки в режим отслеживания можно несколькими способами:

* Если имя локальной ветки отслеживания может совпадать с именем удаленной ветки, применяется
  команда `git checkout --track <удаленный репозиторий>/<удаленная ветка>`. При этом рабочее дерево
  перейдет на соответствующую ветку и включится режим отслеживания. Этот сценарий используется
  настолько часто, что имеет упрощенный вариант команды. Если выполнить `git checkout <имя ветки>` и
  имя ветки совпадает с именем ветки в одном и только одном удаленном репозитории, она автоматически
  переводится в режим отслеживания;
* Имя локальной ветки может отличаться от удаленной. Командой `git checkout -b <имя локальной ветки>
  <имя репозитория>/<имя удаленной ветки>` создается новая ветка с произвольным именем, которая
  отслеживает заданную ветку в удаленном репозитории;
* Если локальная ветка уже имеется в репозитории и нужно перевести ее в режим отслеживания, не меняя
  текущей, можно применить команду `git branch -u <удаленный репозиторий>/<удаленная ветка>
  <локальная ветка>`. Если опустить параметр локальной ветки, то в режим отслеживания перейдет
  локальная ветка с тем же именем, что и удаленная.

Как уже было сказано выше, для отправки изменений в связанный удаленный репозиторий служит команда
`git push`. Без дополнительных параметров она отправляет в удаленную отслеживаемую ветку новые по
отношению к ней изменения из текущей. Операция может завершиться неудачей, если в удаленном
репозитории есть изменения, которых еще нет в локальной ветке. Чтобы выполнить отправку, нужно
сначала притянуть новые изменения командой `git pull`. Без параметров, эта команда забирает новые
изменения из внешней отслеживаемой ветки, переносит их в текущую и производит слияние, если внешняя
и локальная ветки разошлись. Если нужно просто забрать изменения из внешней ветки, но не применять
их пока к текущей, можно применить команду `git fetch`. Она продвигает только указатель удаленной
ветки, не производя слияния с локальной. По умолчанию `git fetch`, как и `git pull`, работает с
удаленным репозиторием `origin`. Чтобы использовать какой-то другой, необходимо добавить его в
качестве дополнительного параметра. Вместо имени удаленного репозитория, можно применить ключ
`--all`. В этом случае будут обновлены все сконфигурированные удаленные репозитории. Если `git
fetch` уже был выполнен, можно выполнить слияние текущей ветки с одной из удаленных. Эту операцию
можно выполнить командой `git merge <имя удаленного репозитория>/<имя удаленной ветки>`. Фактически,
команда `git pull` представляет собой `git fetch` за которым следует слияние.

## Управление удаленными репозиториями

Как было сказано выше, просмотреть список удаленных репозиториев можно командой `git remote`.
Переименовать репозиторий можно командой `git remote rename <старое название> <новое название>`.
Удалить -- командой `git remote rm <имя>`. Команда `git remote prune <имя репозитория>` удаляет в
текущем проекте все ссылки на удаленные ветки, которых больше нет в удаленном репозитории. Наоборот,
удалить те ветки, которых нет в локальном репозитории, но есть во внешнем, можно командой `git push
--prune`. Удалить конкретную внешнюю ветку можно командой `git push <имя репозитория> --delete <имя
ветки>`.


## Задание для самостоятельной работы

* Создайте пустой внешний репозиторий на диске;
* Вытолкните в него все изменения из репозитория, созданного в предыдущей лабораторной работе;
* Перейдите на другую ветку и включите для нее отслеживание соответствующей ветки в удаленном
  репозитории;
* Добавьте в нее изменения и вытолкните их в удаленный репозиторий;
* Создайте новую копию удаленного репозитория путем клонирования;
* Создайте в локальной копии несколько новых веток, затем удалите все ветки, которые не имеют
  аналогов в удаленном репозитории;.
* Удалите одну из локальных веток и сделайте так, чтобы она была удалена и во внешнем репозитории;
* Вернитесь в исходный репозиторий, оставшийся от предыдущей лабораторной работы и добавьте в него
  склонированную копию в качестве дополнительного репозитория с именем, отличающимся от `origin`;
* Удалите ссылку на репозиторий `origin`, затем переименуйте дополнительную ссылку на `origin`.
